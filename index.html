<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>极限功耗测试</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #ffffff;
            color: #000000;
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #ff0000;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .warning {
            background: #fff0f0;
            border: 3px solid #ff0000;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            font-size: 1.1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        #startBtn {
            background: #ff0000;
            color: white;
        }
        
        #stopBtn {
            background: #0000ff;
            color: white;
        }
        
        #maxBtn {
            background: #ff00ff;
            color: white;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-box {
            background: #ffff00;
            border: 2px solid #ff9900;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #ff0000;
            margin: 5px 0;
        }
        
        .visualization {
            height: 200px;
            background: #000000;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        
        .flashing-area {
            position: absolute;
            width: 100%;
            height: 100%;
            animation: flash 0.5s infinite;
        }
        
        @keyframes flash {
            0% { background: #ff0000; }
            25% { background: #00ff00; }
            50% { background: #0000ff; }
            75% { background: #ffff00; }
            100% { background: #ff00ff; }
        }
        
        .pulse {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        .info {
            background: #ffffff;
            border: 2px solid #000000;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.9rem;
        }
        
        .screen-active {
            position: fixed;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0.01;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>⚡极限功耗测试⚡</h1>
        <div class="warning">
            ⚠️ 警告：此页面将最大化设备功耗！会导致严重发热、风扇高速运转、电量快速消耗！使用时间不要超过2分钟！
        </div>
    </div>
    
    <div class="controls">
        <button id="startBtn">开始极限计算</button>
        <button id="stopBtn" disabled>停止计算</button>
        <button id="maxBtn">最大功耗模式</button>
    </div>
    
    <div class="stats">
        <div class="stat-box">
            <div>计算时间</div>
            <div id="timeValue" class="stat-value">0.0s</div>
        </div>
        <div class="stat-box">
            <div>计算次数</div>
            <div id="countValue" class="stat-value">0</div>
        </div>
        <div class="stat-box">
            <div>线程数量</div>
            <div id="threadValue" class="stat-value">0</div>
        </div>
        <div class="stat-box">
            <div>内存使用</div>
            <div id="memoryValue" class="stat-value">0 MB</div>
        </div>
    </div>
    
    <div class="visualization" id="visualization">
        <div class="flashing-area"></div>
    </div>
    
    <div class="info">
        <h3>功耗说明：</h3>
        <p>• 高强度CPU/GPU计算：持续进行数十亿次浮点运算</p>
        <p>• 多线程并行：使用所有可用的CPU核心</p>
        <p>• 高频屏幕刷新：持续高强度屏幕更新防止息屏</p>
        <p>• 大内存占用：创建和操作超大型数据数组</p>
        <p>• 高亮度显示：使用高对比度颜色增加屏幕功耗</p>
    </div>
    
    <!-- 防止息屏的隐藏元素 -->
    <div class="screen-active" id="screenActive"></div>

    <script>
        // 全局变量
        let isRunning = false;
        let startTime = 0;
        let calculationCount = 0;
        let animationFrameId = null;
        let workers = [];
        let memoryArrays = [];
        let maxMode = false;
        
        // DOM元素
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const maxBtn = document.getElementById('maxBtn');
        const timeValue = document.getElementById('timeValue');
        const countValue = document.getElementById('countValue');
        const threadValue = document.getElementById('threadValue');
        const memoryValue = document.getElementById('memoryValue');
        const visualization = document.getElementById('visualization');
        const screenActive = document.getElementById('screenActive');
        
        // 防止屏幕关闭的机制
        let wakeLock = null;
        let preventSleepInterval = null;
        
        // 尝试获取屏幕唤醒锁
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('屏幕唤醒锁已激活');
                } catch (err) {
                    console.error(`唤醒锁错误: ${err.message}`);
                }
            }
            
            // 后备方案：持续移动微小元素防止息屏
            preventSleepInterval = setInterval(() => {
                // 持续微小的DOM更新防止息屏
                screenActive.style.transform = `translate(${Math.random()*0.1}px, ${Math.random()*0.1}px)`;
                
                // 后备方案：如果有video元素，可以播放视频防止息屏
                // 但对于纯JavaScript方案，我们使用持续动画
            }, 1000);
        }
        
        // 高强度计算函数 - 优化的计算密集型任务
        function intensiveCalculation() {
            let result = 0;
            const size = maxMode ? 100000 : 50000;
            
            // 创建多个大型数组增加内存压力
            if (memoryArrays.length < 10) {
                const newArray = new Float64Array(size);
                for (let i = 0; i < size; i++) {
                    newArray[i] = Math.random() * 1000;
                }
                memoryArrays.push(newArray);
            }
            
            // 执行密集型数学计算
            for (let i = 0; i < size; i++) {
                // 复杂数学运算链
                const x = Math.random() * 1000;
                result += Math.sin(x) * Math.cos(x) * Math.tan(x * 0.01);
                result += Math.exp(x * 0.001) * Math.log(x + 1);
                result += Math.sqrt(x) * Math.pow(x, 0.7);
                
                // 三角函数运算
                result += Math.atan2(x, i + 1) * Math.asin((x % 100) / 100);
                result += Math.acos((x % 100) / 100) * Math.atan(x);
                
                // 双曲函数计算
                result += Math.sinh(x * 0.01) * Math.cosh(x * 0.01);
                result += Math.tanh(x * 0.01) * Math.asinh(x);
                
                // 幂运算和对数运算
                result += Math.pow(x, 1.5) * Math.log10(x + 1);
                result += Math.pow(x, 0.33) * Math.log2(x + 1);
                
                // 更多随机运算
                result += (x * x * x) / (x + 1);
                result += Math.sqrt(x * x + x + 1);
                result += Math.abs(Math.sin(x) * Math.cos(x * 2));
            }
            
            // 对内存数组进行排序和操作
            memoryArrays.forEach(array => {
                // 创建数组副本并排序
                const sorted = new Float64Array(array);
                sorted.sort();
                
                // 查找操作
                for (let j = 0; j < 1000; j++) {
                    const target = Math.random() * 1000;
                    const index = binarySearch(sorted, target);
                    result += index || 0;
                }
            });
            
            calculationCount++;
            return result;
        }
        
        // 二分查找算法增加计算复杂度
        function binarySearch(arr, target) {
            let left = 0;
            let right = arr.length - 1;
            
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                
                // 额外计算增加复杂度
                for (let k = 0; k < 10; k++) {
                    target += Math.sin(mid) * 0.0001;
                }
                
                if (Math.abs(arr[mid] - target) < 0.001) {
                    return mid;
                }
                
                if (arr[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            return -1;
        }
        
        // 创建高强度Web Workers
        function createIntensiveWorkers() {
            // 清理现有workers
            cleanupWorkers();
            
            // 确定要创建的worker数量
            const cpuCores = navigator.hardwareConcurrency || 4;
            const workerCount = maxMode ? Math.max(4, cpuCores * 2) : Math.max(2, cpuCores);
            
            for (let i = 0; i < workerCount; i++) {
                const workerCode = `
                    let localResult = 0;
                    let localMemory = [];
                    
                    self.onmessage = function(e) {
                        const intensity = e.data.intensity || 10;
                        const taskSize = e.data.taskSize || 50000;
                        
                        // Worker内部的重计算
                        for (let cycle = 0; cycle < 3; cycle++) {
                            // 创建本地内存数组
                            if (localMemory.length < 5) {
                                const arr = new Float64Array(taskSize);
                                for (let j = 0; j < taskSize; j++) {
                                    arr[j] = Math.random() * 1000;
                                }
                                localMemory.push(arr);
                            }
                            
                            // 执行复杂计算
                            for (let j = 0; j < taskSize; j++) {
                                const x = Math.random() * 1000;
                                localResult += Math.sin(x) * Math.cos(x * 0.5) * Math.tan(x * 0.01);
                                localResult += Math.exp(x * 0.001) * Math.log(x + 1);
                                localResult += Math.sqrt(x) * Math.pow(x, 0.7);
                                localResult += Math.atan2(x, j + 1);
                                localResult += Math.sinh(x * 0.01) * Math.cosh(x * 0.01);
                                
                                // 矩阵乘法模拟
                                for (let k = 0; k < 10; k++) {
                                    localResult += (x * k) / (x + k + 1);
                                }
                            }
                            
                            // 对本地数组排序
                            localMemory.forEach(arr => {
                                const sorted = new Float64Array(arr);
                                sorted.sort();
                                
                                // 额外查找操作
                                for (let j = 0; j < 100; j++) {
                                    const target = Math.random() * 1000;
                                    let found = false;
                                    for (let k = 0; k < Math.min(1000, sorted.length); k++) {
                                        if (Math.abs(sorted[k] - target) < 0.1) {
                                            found = true;
                                            break;
                                        }
                                    }
                                    if (found) localResult += 0.001;
                                }
                            });
                        }
                        
                        // 偶尔发送结果（但主要是为了持续计算）
                        if (Math.random() > 0.9) {
                            self.postMessage({result: localResult});
                        }
                    };
                `;
                
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));
                
                // 持续向worker发送计算任务
                const intervalId = setInterval(() => {
                    if (isRunning) {
                        worker.postMessage({
                            intensity: maxMode ? 20 : 10,
                            taskSize: maxMode ? 100000 : 50000
                        });
                    }
                }, 50); // 非常高的频率
                
                workers.push({
                    worker,
                    intervalId,
                    startTime: Date.now()
                });
            }
            
            threadValue.textContent = workerCount;
        }
        
        // 清理Web Workers
        function cleanupWorkers() {
            workers.forEach(w => {
                clearInterval(w.intervalId);
                w.worker.terminate();
            });
            workers = [];
            threadValue.textContent = '0';
        }
        
        // 创建视觉特效增加GPU负载
        function createVisualEffects() {
            // 清除现有特效
            const existingPulses = document.querySelectorAll('.pulse');
            existingPulses.forEach(p => p.remove());
            
            // 创建多个脉动效果
            for (let i = 0; i < (maxMode ? 20 : 10); i++) {
                setTimeout(() => {
                    if (!isRunning) return;
                    
                    const pulse = document.createElement('div');
                    pulse.className = 'pulse';
                    pulse.style.left = `${Math.random() * 100}%`;
                    pulse.style.top = `${Math.random() * 100}%`;
                    pulse.style.width = `${10 + Math.random() * 30}px`;
                    pulse.style.height = pulse.style.width;
                    pulse.style.animationDuration = `${0.5 + Math.random() * 1.5}s`;
                    pulse.style.backgroundColor = `rgb(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255})`;
                    
                    visualization.appendChild(pulse);
                    
                    // 动画结束后移除
                    setTimeout(() => {
                        if (pulse.parentNode) {
                            pulse.remove();
                        }
                    }, 2000);
                }, i * 100);
            }
        }
        
        // 主要计算循环
        function calculationLoop() {
            if (!isRunning) return;
            
            // 执行主线程高强度计算
            intensiveCalculation();
            
            // 更新统计信息
            updateStats();
            
            // 定期更新视觉特效
            if (calculationCount % 10 === 0) {
                createVisualEffects();
            }
            
            // 使用requestAnimationFrame保持高刷新率
            animationFrameId = requestAnimationFrame(calculationLoop);
        }
        
        // 更新统计信息
        function updateStats() {
            // 计算时间
            const elapsed = (Date.now() - startTime) / 1000;
            timeValue.textContent = elapsed.toFixed(1) + 's';
            
            // 计算次数
            countValue.textContent = calculationCount.toLocaleString();
            
            // 内存使用估算
            const memoryUsage = memoryArrays.length * 50 + calculationCount * 0.001;
            memoryValue.textContent = Math.round(memoryUsage) + ' MB';
        }
        
        // 最大功耗模式
        function enableMaxPowerMode() {
            maxMode = true;
            maxBtn.disabled = true;
            maxBtn.textContent = '最大功耗模式已激活';
            maxBtn.style.background = '#ff0000';
            
            // 增加计算强度
            if (isRunning) {
                cleanupWorkers();
                createIntensiveWorkers();
            }
            
            // 最大化屏幕亮度效果
            document.body.style.background = '#ffffff';
            document.body.style.color = '#000000';
            
            // 持续闪烁警告
            const warning = document.querySelector('.warning');
            warning.style.animation = 'flash 0.3s infinite';
            
            alert('⚠️ 最大功耗模式已激活！设备将承受极限负载！请在30秒内停止测试以避免过热损坏！');
        }
        
        // 事件监听
        startBtn.addEventListener('click', async () => {
            if (isRunning) return;
            
            isRunning = true;
            startTime = Date.now();
            calculationCount = 0;
            memoryArrays = [];
            
            startBtn.disabled = true;
            stopBtn.disabled = false;
            maxBtn.disabled = false;
            
            // 激活防止息屏
            await requestWakeLock();
            
            // 创建Web Workers
            createIntensiveWorkers();
            
            // 开始主计算循环
            calculationLoop();
            
            // 启动视觉特效
            createVisualEffects();
            setInterval(createVisualEffects, 2000);
        });
        
        stopBtn.addEventListener('click', () => {
            isRunning = false;
            maxMode = false;
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // 清理资源
            cleanupWorkers();
            memoryArrays = [];
            
            // 释放唤醒锁
            if (wakeLock) {
                wakeLock.release().then(() => {
                    wakeLock = null;
                });
            }
            
            if (preventSleepInterval) {
                clearInterval(preventSleepInterval);
                preventSleepInterval = null;
            }
            
            // 重置按钮状态
            startBtn.disabled = false;
            stopBtn.disabled = true;
            maxBtn.disabled = false;
            maxBtn.textContent = '最大功耗模式';
            maxBtn.style.background = '#ff00ff';
            
            // 停止闪烁
            const warning = document.querySelector('.warning');
            warning.style.animation = '';
            
            alert('计算已停止。设备可能需要时间冷却。');
        });
        
        maxBtn.addEventListener('click', enableMaxPowerMode);
        
        // 页面卸载时清理
        window.addEventListener('beforeunload', (e) => {
            if (isRunning) {
                e.preventDefault();
                e.returnValue = '测试仍在运行，确定要离开吗？';
                return e.returnValue;
            }
        });
        
        // 初始化
        console.log('极限功耗测试页面已加载。使用前请阅读警告！');
    </script>
</body>
</html>
